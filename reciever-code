/*
  Receiver for Optimized 3-Tank Sender (extended packets)
  - Accepts legacy StructMessage { TankData tanks[3] } OR
    extended StructMessageExt { TankData tanks[3]; uint32_t seq; uint32_t ts_ms; uint16_t crc16; }
  - Validates CRC for extended packets, uses seq to sync display paging
  - Shows one tank per page on 20x4 HD44780 via I2C expander
*/

#include <Wire.h>
#include <hd44780.h>
#include <hd44780ioClass/hd44780_I2Cexp.h>
#include <WiFi.h>
#include <WiFiUdp.h>

hd44780_I2Cexp lcd;

// ====== NETWORK CONFIG - EDIT IF NEEDED ======
const char* WIFI_SSID = "Airtel_7737476759";
const char* WIFI_PASS = "air49169";

// optional static IP (keep or change to DHCP by removing WiFi.config)
IPAddress RECV_LOCAL_IP(192,168,1,100);
IPAddress RECV_GATEWAY(192,168,1,1);
IPAddress RECV_SUBNET(255,255,255,0);

const uint16_t UDP_PORT = 4210; // must match sender

// ====== APPLICATION CONFIG ======
const int NUM_TANKS = 3;
const unsigned long PAGE_DELAY_MS = 4000;   // show each tank for 4s
const unsigned long STALE_MS = 12000;       // consider data stale after 12s
const unsigned long RECENT_MS = 1000;       // "<1s" label threshold

// ====== PACKET STRUCTS (must match sender) ======
struct TankData { char name[16]; float levelPercent; };
struct StructMessage { TankData tanks[NUM_TANKS]; };

// Extended struct: tanks + seq + timestamp + crc16
struct StructMessageExt {
  TankData tanks[NUM_TANKS];
  uint32_t seq;
  uint32_t ts_ms;
  uint16_t crc16; // CRC over preceding bytes
};

// ====== INTERNAL STORAGE ======
struct Slot {
  char name[16];
  float levelPercent;
  unsigned long lastUpdate;
};
Slot slots[NUM_TANKS];
volatile bool anyDataReceived = false;

WiFiUDP Udp;

// ====== CRC16 (XMODEM-style) ======
uint16_t crc16_update(uint16_t crc, uint8_t a) {
  crc ^= (uint16_t)a << 8;
  for (int i = 0; i < 8; ++i) {
    if (crc & 0x8000) crc = (crc << 1) ^ 0x1021;
    else crc <<= 1;
  }
  return crc & 0xFFFF;
}
uint16_t calc_crc16(const uint8_t *buf, size_t len) {
  uint16_t crc = 0;
  for (size_t i = 0; i < len; ++i) crc = crc16_update(crc, buf[i]);
  return crc;
}

// --- helpers
void initSlots() {
  for (int i = 0; i < NUM_TANKS; i++) {
    slots[i].name[0] = '\0';
    slots[i].levelPercent = -1.0f;
    slots[i].lastUpdate = 0;
  }
}

void safePrintLine(int row, const char* txt) {
  lcd.setCursor(0, row);
  char buf[21];
  memset(buf, ' ', 20);
  buf[20] = '\0';
  int len = strlen(txt);
  if (len > 20) len = 20;
  memcpy(buf, txt, len);
  lcd.print(buf);
}

// === SHOW NO DATA SCREEN (with MAC + IP) ===
void showNoDataInfo() {
  lcd.clear();
  safePrintLine(0, "No Data");
  safePrintLine(1, WiFi.macAddress().c_str());
  String ip = WiFi.localIP().toString();
  safePrintLine(2, ip.c_str());
  safePrintLine(3, "Waiting for packets...");
}

void showTankPage(int idx) {
  lcd.clear();

  if (slots[idx].name[0] == '\0') {
    char s[21];
    snprintf(s, sizeof(s), "Tank %d (empty)", idx+1);
    safePrintLine(0, s);
    safePrintLine(1, "No data received");
    safePrintLine(2, "");
    safePrintLine(3, "");
    return;
  }

  safePrintLine(0, slots[idx].name);

  unsigned long now = millis();
  unsigned long age = (slots[idx].lastUpdate == 0) ? ULONG_MAX : (now - slots[idx].lastUpdate);

  if (slots[idx].lastUpdate == 0 || age > STALE_MS) {
    safePrintLine(1, "No data received");
    safePrintLine(2, "");
    safePrintLine(3, "");
    return;
  }

  // Level line
  char line1[21];
  char pct[12];
  if (slots[idx].levelPercent < 0) strcpy(pct, "--.-");
  else dtostrf(slots[idx].levelPercent, 5, 1, pct);
  snprintf(line1, sizeof(line1), "Level: %s %%", pct);
  safePrintLine(1, line1);

  // optional middle line (blank)
  safePrintLine(2, "");

  // Updated age
  char line3[21];
  if (age <= RECENT_MS) snprintf(line3, sizeof(line3), "Updated: <1s ago");
  else {
    unsigned long secs = age / 1000;
    if (secs < 60) snprintf(line3, sizeof(line3), "Updated: %lus ago", secs);
    else {
      unsigned long mins = secs / 60;
      snprintf(line3, sizeof(line3), "Updated: %lumin ago", mins);
    }
  }
  safePrintLine(3, line3);
}

// ====== UDP receive handler (accept legacy or extended) ======
unsigned long lastPacketMs = 0;
unsigned long lastRefresh = 0;
int currentPage = 0;
unsigned long lastPageMs = 0;

void handleUdp() {
  int packetSize = Udp.parsePacket();
  if (packetSize <= 0) return;

  const size_t MAX_BUF = 512;
  static uint8_t buf[MAX_BUF];
  int readLen = Udp.read(buf, MAX_BUF);
  if (readLen <= 0) return;

  unsigned long now = millis();

  // Case A: exact legacy size
  if ((size_t)readLen == sizeof(StructMessage)) {
    StructMessage msg;
    memcpy(&msg, buf, sizeof(msg));
    for (int i = 0; i < NUM_TANKS; ++i) {
      msg.tanks[i].name[15] = '\0';
      strncpy(slots[i].name, msg.tanks[i].name, sizeof(slots[i].name));
      slots[i].name[sizeof(slots[i].name)-1] = '\0';
      slots[i].levelPercent = msg.tanks[i].levelPercent;
      slots[i].lastUpdate = now;
      Serial.printf("LEGACY Slot %d <= %s = %.1f\n", i, slots[i].name, slots[i].levelPercent);
    }
    anyDataReceived = true;
    // legacy: reset paging to 0 at receipt time (or keep as-is â€” choose reset)
    currentPage = 0;
    lastPageMs = now;
    lastPacketMs = now;
    return;
  }

  // Case B: possible extended size
  if ((size_t)readLen == sizeof(StructMessageExt)) {
    StructMessageExt ext;
    memcpy(&ext, buf, sizeof(ext));
    // compute CRC over everything except crc16 (last 2 bytes)
    uint16_t computed = calc_crc16(buf, sizeof(StructMessageExt) - sizeof(ext.crc16));
    if (computed != ext.crc16) {
      Serial.printf("EXT CRC mismatch: got 0x%04X computed 0x%04X - ignoring\n", ext.crc16, computed);
      return;
    }
    // accept extended packet
    for (int i = 0; i < NUM_TANKS; ++i) {
      ext.tanks[i].name[15] = '\0';
      strncpy(slots[i].name, ext.tanks[i].name, sizeof(slots[i].name));
      slots[i].name[sizeof(slots[i].name)-1] = '\0';
      slots[i].levelPercent = ext.tanks[i].levelPercent;
      slots[i].lastUpdate = now;
      Serial.printf("EXT Slot %d <= %s = %.1f\n", i, slots[i].name, slots[i].levelPercent);
    }
    anyDataReceived = true;

    // Sync: use seq to set start page (wrap-safe)
    uint32_t seq = ext.seq;
    currentPage = (int)(seq % (uint32_t)NUM_TANKS);
    lastPageMs = now;
    lastPacketMs = now;
    Serial.printf("EXT seq=%u ts_ms=%u -> startPage=%d\n", ext.seq, ext.ts_ms, currentPage);
    return;
  }

  // Other sizes: if >= legacy size, parse first legacy portion (best-effort)
  if ((size_t)readLen >= sizeof(StructMessage)) {
    StructMessage msg;
    memcpy(&msg, buf, sizeof(msg));
    for (int i = 0; i < NUM_TANKS; ++i) {
      msg.tanks[i].name[15] = '\0';
      strncpy(slots[i].name, msg.tanks[i].name, sizeof(slots[i].name));
      slots[i].name[sizeof(slots[i].name)-1] = '\0';
      slots[i].levelPercent = msg.tanks[i].levelPercent;
      slots[i].lastUpdate = now;
    }
    anyDataReceived = true;
    // don't try to sync seq if not full extended
    currentPage = 0;
    lastPageMs = now;
    lastPacketMs = now;
    Serial.printf("PARTIAL packet parsed (size=%d)\n", readLen);
    return;
  }

  // else ignore too small packet
  Serial.printf("UDP: packet too small (%d bytes) ignored\n", readLen);
}

// ====== SETUP / LOOP ======
void setup() {
  Serial.begin(115200);
  delay(50);
  Serial.println("Receiver (extended-compatible) starting...");

  // I2C pins for ESP32 defaults (SDA=21, SCL=22)
  Wire.begin(21, 22);
  lcd.begin(20, 4);
  lcd.backlight();
  lcd.clear();

  initSlots();

  // configure static IP if desired (optional)
  if (!WiFi.config(RECV_LOCAL_IP, RECV_GATEWAY, RECV_SUBNET)) {
    Serial.println("WiFi.config() failed (continuing, may still use DHCP)");
  }
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.printf("Connecting to %s ...\n", WIFI_SSID);
  unsigned long start = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - start < 15000) {
    delay(200); Serial.print(".");
  }
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("\nWiFi connect failed");
    safePrintLine(0, "WiFi failed");
    while (true) delay(1000);
  }

  Serial.println("\nWiFi connected");
  Serial.print("IP: "); Serial.println(WiFi.localIP());
  Serial.print("MAC: "); Serial.println(WiFi.macAddress());

  if (Udp.begin(UDP_PORT) != 1) {
    Serial.printf("Udp.begin(%d) failed\n", UDP_PORT);
  } else Serial.printf("Listening UDP port %d\n", UDP_PORT);

  // initial info screen
  showNoDataInfo();
  lastPageMs = millis();
  lastRefresh = millis();
  lastPacketMs = 0;
}

void loop() {
  handleUdp();

  unsigned long now = millis();

  if (!anyDataReceived) {
    if (now - lastRefresh > 1000) { showNoDataInfo(); lastRefresh = now; }
    return;
  }

  // paging: lastPageMs is reset when packets arrive (sync)
  if (now - lastPageMs >= PAGE_DELAY_MS) {
    currentPage++;
    if (currentPage >= NUM_TANKS) currentPage = 0;
    showTankPage(currentPage);
    lastPageMs = now;
    lastRefresh = now;
  } else {
    // refresh "Updated: Xs ago"
    if (now - lastRefresh >= 1000) { showTankPage(currentPage); lastRefresh = now; }
  }
}
